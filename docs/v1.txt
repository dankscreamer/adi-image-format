ADI Image Format — v1 Documentation
Overview

ADI (Adit Image) is a simple binary image container format designed to store raw pixel data along with minimal metadata.

ADI is intentionally not a compressed format like JPG or PNG.
It is meant to be a stable, low-level container that other tools can build on (encryption, sharing, viewing, etc.).

Design Goals

Simple and explicit binary layout

Easy to read and write in C

Self-describing (dimensions stored in file)

Suitable for future extensions (versioning, encryption)

No compression, no decoding logic

Non-Goals (v1)

No JPG/PNG decoding

No compression

No image display

No encryption (planned for later versions)

File Layout (ADI v1)

An ADI file consists of two parts, written in order:

[ ADIHeader ][ Pixel Data ]

1. ADIHeader

The header is written directly as a C struct.

struct ADIHeader {
    char magic[3];            // Must be 'A', 'D', 'I'
    int width;                // Image width in pixels
    int height;               // Image height in pixels
    unsigned char channels;   // Number of channels (1 = grayscale, 3 = RGB)
};

Header Notes

magic identifies the file as ADI

width and height must be positive

channels must be 1 or 3

Header size is fixed for v1

Header is stored uncompressed and unencrypted

2. Pixel Data

Immediately after the header, raw pixel bytes are stored.

pixel_count = width × height × channels


Each pixel channel is 1 byte (0–255)

Pixels are stored in row-major order

RGB pixels are stored as:

R, G, B, R, G, B, ...

API Overview

ADI v1 exposes two functions.

Writing an ADI file
int write_adi(const char *filename,
              struct ADIHeader *header,
              unsigned char *pixels);

Behavior

Writes the header first

Writes raw pixel data immediately after

Returns 0 on success

Returns non-zero on failure

Reading an ADI file
unsigned char *read_adi(const char *filename,
                        struct ADIHeader *out_header);

Behavior

Reads and validates the header

Allocates memory for pixel data

Reads pixel bytes into allocated memory

Returns pointer to pixel data on success

Returns NULL on failure

Caller must free the returned buffer

Validation Rules

When reading an ADI file, the following checks are enforced:

magic == "ADI"

width > 0

height > 0

channels == 1 || channels == 3

Files failing validation are rejected.

Memory Ownership

write_adi does not allocate memory

read_adi allocates pixel memory using malloc

The caller is responsible for calling free

Example Use Case
struct ADIHeader header;
header.magic[0] = 'A';
header.magic[1] = 'D';
header.magic[2] = 'I';
header.width = 2;
header.height = 2;
header.channels = 3;

unsigned char pixels[12] = {
    255, 0, 0,
    0, 255, 0,
    0, 0, 255,
    255, 255, 255
};

write_adi("image.adi", &header, pixels);

Testing

ADI v1 correctness is verified using a round-trip test:

pixels → write_adi → file → read_adi → pixels


The test checks:

Header equality

Byte-for-byte pixel equality

If the round-trip preserves data, the format is considered correct.

Portability Notes

ADI v1 assumes the same endianness between writer and reader

Struct layout is compiler-dependent

Future versions may add explicit versioning and fixed-width types

Versioning

This document describes ADI v1.

Future versions may:

Add a version field to the header

Add payload size or checksum

Add encryption metadata

Maintain backward compatibility where possible

Summary

ADI v1 is:

A raw image container

Simple, explicit, and testable

A stable foundation for future features

ADI v1 is complete.
